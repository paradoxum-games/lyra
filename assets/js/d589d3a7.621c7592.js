"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[924],{6475:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"getting-started","title":"Getting Started","description":"Let\'s get Lyra set up in your game and cover the basics of saving player data.","source":"@site/docs/getting-started.md","sourceDirName":".","slug":"/getting-started","permalink":"/lyra/docs/getting-started","draft":false,"unlisted":false,"editUrl":"https://github.com/paradoxum-games/lyra/edit/main/docs/getting-started.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"defaultSidebar","previous":{"title":"Introduction","permalink":"/lyra/docs/intro"},"next":{"title":"Core Concepts","permalink":"/lyra/docs/core-concepts"}}');var r=a(4848),s=a(8453);const i={sidebar_position:2},o="Getting Started",l={},c=[{value:"Installation",id:"installation",level:2},{value:"Basic Setup",id:"basic-setup",level:2},{value:"Working with Data",id:"working-with-data",level:2},{value:"Reading Data",id:"reading-data",level:3},{value:"Modifying Data",id:"modifying-data",level:3},{value:"Trading Between Players",id:"trading-between-players",level:3},{value:"Importing Existing Data",id:"importing-existing-data",level:2},{value:"ProcessReceipt Example",id:"processreceipt-example",level:2},{value:"Promise-based API",id:"promise-based-api",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"getting-started",children:"Getting Started"})}),"\n",(0,r.jsx)(n.p,{children:"Let's get Lyra set up in your game and cover the basics of saving player data."}),"\n",(0,r.jsx)(n.h2,{id:"installation",children:"Installation"}),"\n",(0,r.jsxs)(n.p,{children:["Add Lyra to your ",(0,r.jsx)(n.code,{children:"wally.toml"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-toml",children:'Lyra = "paradoxum-games/lyra@0.4.0"\n'})}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsxs)(n.p,{children:["If you're new to Wally, check out the ",(0,r.jsx)(n.a,{href:"https://wally.run/install",children:"Wally installation guide"}),"."]})}),"\n",(0,r.jsx)(n.h2,{id:"basic-setup",children:"Basic Setup"}),"\n",(0,r.jsx)(n.p,{children:"Here's how to set up Lyra with a simple data structure:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'local Players = game:GetService("Players")\nlocal Lyra = require(path.to.Lyra)\n\n-- Define your data template\nlocal template = {\n    coins = 0,\n    inventory = {},\n}\n\n-- Create schema to validate data\nlocal schema = t.strictInterface({\n    coins = t.number,\n    inventory = t.table,\n})\n\n-- Create the store\nlocal store = Lyra.createPlayerStore({\n    name = "PlayerData",\n    template = template,\n    schema = schema,\n})\n\n-- Load data when players join\nPlayers.PlayerAdded:Connect(function(player)\n    store:loadAsync(player)\nend)\n\n-- Save and clean up when they leave\nPlayers.PlayerRemoving:Connect(function(player)\n    store:unloadAsync(player)\nend)\n\n-- Ensure data is saved when the game closes\ngame:BindToClose(function()\n    store:closeAsync()\nend)\n'})}),"\n",(0,r.jsx)(n.h2,{id:"working-with-data",children:"Working with Data"}),"\n",(0,r.jsx)(n.h3,{id:"reading-data",children:"Reading Data"}),"\n",(0,r.jsx)(n.p,{children:"You can read player data, but remember that it might change between reads:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:"-- \u26a0\ufe0f Only use this data for reading\n-- Don't save it for later use\nlocal data = store:getAsync(player)\nprint(`{player.Name} has {data.coins} coins`)\n"})}),"\n",(0,r.jsx)(n.h3,{id:"modifying-data",children:"Modifying Data"}),"\n",(0,r.jsx)(n.p,{children:"Always modify data through update functions:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:"-- Simple update\nstore:updateAsync(player, function(data)\n    data.coins += 100\n    return true\nend)\n\n-- Conditional update\nstore:updateAsync(player, function(data)\n    if data.coins < itemPrice then\n        return false -- Abort the update\n    end\n    \n    data.coins -= itemPrice\n    table.insert(data.inventory, itemId)\n    return true\nend)\n"})}),"\n",(0,r.jsx)(n.h3,{id:"trading-between-players",children:"Trading Between Players"}),"\n",(0,r.jsx)(n.p,{children:"Use transactions for operations involving multiple players:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:"store:txAsync({player1, player2}, function(state)\n    -- Transfer coins\n    if state[player1].coins < amount then\n        return false -- Abort if not enough coins\n    end\n    \n    state[player1].coins -= amount\n    state[player2].coins += amount\n    return true\nend)\n"})}),"\n",(0,r.jsx)(n.h2,{id:"importing-existing-data",children:"Importing Existing Data"}),"\n",(0,r.jsx)(n.p,{children:"If you're migrating from another DataStore library, you can import your existing data:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'local store = Lyra.createPlayerStore({\n    name = "PlayerData",\n    template = template,\n    schema = schema,\n    importLegacyData = function(key)\n        local success, data = pcall(function()\n            return YourCurrentSystem.getData(key)\n        end)\n        \n        if not success then\n            error("Failed to reach data system") -- Player will be kicked and can retry\n        end\n\n        if data ~= nil then\n            return data -- Return existing data to import\n        end\n        \n        return nil -- Return nil for new players to use template\n    end,\n})\n'})}),"\n",(0,r.jsx)(n.h2,{id:"processreceipt-example",children:"ProcessReceipt Example"}),"\n",(0,r.jsx)(n.p,{children:"Here's an example of how you would use Lyra in ProcessReceipt:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:"local ProductCallbacks = {\n    [12345] = function(player, receiptInfo, data)\n        data.coins += 100\n        return true\n    end,\n}\n\nlocal function processReceipt(receiptInfo)\n    local player = Players:GetPlayerByUserId(receiptInfo.PlayerId)\n    if not player then\n        return Enum.ProductPurchaseDecision.NotProcessedYet\n    end\n\n    local productCallback = ProductCallbacks[receiptInfo.ProductId]\n    if not productCallback then\n        return Enum.ProductPurchaseDecision.NotProcessedYet\n    end\n\n    local ok, result = pcall(function()\n        store:updateAsync(player, function(data)\n            -- Assuming you have 'purchaseHistory' in your template and schema:\n            if table.find(data.purchaseHistory, receiptInfo.PurchaseId) then\n               return false -- Prevent duplicate purchases\n            end\n            table.insert(data.purchaseHistory, receiptInfo.PurchaseId, 1)\n            for i = 1000, #data.purchaseHistory do\n                data.purchaseHistory[i] = nil -- Remove old purchases\n            end\n\n            return productCallback(player, receiptInfo, data)\n        end)\n        store:saveAsync(player)\n    end)\n    if not ok then\n        warn(`ProcessReceipt failed: {result}`)\n        return Enum.ProductPurchaseDecision.NotProcessedYet\n    end\n\n    return Enum.ProductPurchaseDecision.PurchaseGranted\nend\n"})}),"\n",(0,r.jsx)(n.h2,{id:"promise-based-api",children:"Promise-based API"}),"\n",(0,r.jsx)(n.p,{children:"Lyra also offers a Promise-based API:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'store:update(player, function(data)\n    data.coins -= itemPrice\n    data.inventory.weapon = "starter_sword"\n    return true\nend):andThen(function()\n    print("Purchase successful!")\nend):catch(function(err)\n    print(`Purchase failed: {err}`)\nend)\n'})}),"\n",(0,r.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,r.jsx)(n.p,{children:"Now that you've got the basics down, check out:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/lyra/docs/core-concepts",children:"Core Concepts"})," for a deeper understanding"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/lyra/docs/advanced/migrations",children:"Data Migrations"})," for updating data structure"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/lyra/docs/advanced/networking",children:"Network Updates"})," for client synchronization"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/lyra/docs/advanced/debugging",children:"Debugging"})," for troubleshooting"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,a)=>{a.d(n,{R:()=>i,x:()=>o});var t=a(6540);const r={},s=t.createContext(r);function i(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);